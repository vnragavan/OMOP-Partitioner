#!/usr/bin/env python3
"""
OMOP Partition Credential Extractor

This script helps end users extract database credentials from partition configuration files
and provides security recommendations for production use.
"""

import yaml
import os
import sys
import argparse
from pathlib import Path
from typing import Dict, List, Optional


def load_config(config_path: str) -> Dict:
    """Load configuration from YAML file."""
    try:
        with open(config_path, 'r') as f:
            return yaml.safe_load(f)
    except FileNotFoundError:
        print(f"‚ùå Configuration file not found: {config_path}")
        sys.exit(1)
    except yaml.YAMLError as e:
        print(f"‚ùå Error parsing YAML file: {e}")
        sys.exit(1)


def extract_credentials(config: Dict) -> Dict:
    """Extract database credentials from configuration."""
    if 'database' not in config:
        print("‚ùå No database configuration found in config file")
        return {}
    
    db_config = config['database']
    return {
        'username': db_config.get('POSTGRES_USER', 'postgres'),
        'password': db_config.get('POSTGRES_PASSWORD', 'postgres'),
        'database': db_config.get('POSTGRES_DB', 'omop'),
        'host': 'localhost',
        'port': db_config.get('HOST_PORT', '5432'),
        'connection_string': db_config.get('CONNECTION_STRING', ''),
        'container_connection_string': db_config.get('CONTAINER_CONNECTION_STRING', '')
    }


def print_credentials(credentials: Dict, partition_name: str = "Unknown"):
    """Print credentials in a formatted way."""
    print(f"\nüîê Database Credentials for {partition_name}")
    print("=" * 50)
    print(f"Username:     {credentials['username']}")
    print(f"Password:     {credentials['password']}")
    print(f"Database:     {credentials['database']}")
    print(f"Host:         {credentials['host']}")
    print(f"Port:         {credentials['port']}")
    print(f"Connection:   {credentials['connection_string']}")
    print()


def print_security_warning():
    """Print security warning and recommendations."""
    print("\n‚ö†Ô∏è  SECURITY WARNING")
    print("=" * 50)
    print("These are DEFAULT credentials and are NOT secure for production use!")
    print("\nüîí Security Recommendations:")
    print("1. Change passwords immediately after first login")
    print("2. Use environment variables for credential management")
    print("3. Implement proper authentication mechanisms")
    print("4. Restrict network access to database ports")
    print("5. Use read-only users for analytics workloads")
    print("6. Enable SSL/TLS connections")
    print("7. Set up monitoring and logging")
    print("8. Regular security audits")
    print()


def generate_connection_script(credentials: Dict, partition_name: str) -> str:
    """Generate a connection script for the database."""
    script = f"""#!/bin/bash
# Connection script for {partition_name}
# Generated by extract_credentials.py

echo "Connecting to {partition_name} database..."

# Method 1: Using psql with connection string
psql "{credentials['connection_string']}"

# Method 2: Using psql with individual parameters
# psql -h {credentials['host']} -p {credentials['port']} -U {credentials['username']} -d {credentials['database']}

# Method 3: Using environment variables
# export PGHOST={credentials['host']}
# export PGPORT={credentials['port']}
# export PGUSER={credentials['username']}
# export PGPASSWORD={credentials['password']}
# export PGDATABASE={credentials['database']}
# psql
"""
    return script


def generate_env_file(credentials: Dict, partition_name: str) -> str:
    """Generate a .env file for the database."""
    env_content = f"""# Environment variables for {partition_name}
# Generated by extract_credentials.py

POSTGRES_USER={credentials['username']}
POSTGRES_PASSWORD={credentials['password']}
POSTGRES_DB={credentials['database']}
POSTGRES_HOST={credentials['host']}
POSTGRES_PORT={credentials['port']}

# Connection string
DATABASE_URL={credentials['connection_string']}

# Docker run command with these credentials:
# docker run -d -p {credentials['port']}:5432 \\
#   -e POSTGRES_USER={credentials['username']} \\
#   -e POSTGRES_PASSWORD={credentials['password']} \\
#   -e POSTGRES_DB={credentials['database']} \\
#   --name {partition_name}_restored \\
#   ghcr.io/username/omop-partitions-{partition_name}:latest
"""
    return env_content


def main():
    parser = argparse.ArgumentParser(
        description="Extract database credentials from OMOP partition configuration files"
    )
    parser.add_argument(
        "config_file",
        help="Path to partition configuration file (e.g., partition_0_config.yaml)"
    )
    parser.add_argument(
        "--generate-script",
        action="store_true",
        help="Generate connection script"
    )
    parser.add_argument(
        "--generate-env",
        action="store_true",
        help="Generate .env file"
    )
    parser.add_argument(
        "--all-partitions",
        action="store_true",
        help="Process all partitions from all_partitions_config.yaml"
    )
    
    args = parser.parse_args()
    
    if args.all_partitions:
        # Process all partitions
        config = load_config(args.config_file)
        if 'partitions' not in config:
            print("‚ùå No partitions found in configuration file")
            sys.exit(1)
        
        print(f"üìã Found {len(config['partitions'])} partitions")
        
        for i, partition in enumerate(config['partitions']):
            partition_name = partition.get('container', {}).get('name', f'partition_{i}')
            credentials = extract_credentials(partition)
            print_credentials(credentials, partition_name)
            
            if args.generate_script:
                script_content = generate_connection_script(credentials, partition_name)
                script_file = f"connect_{partition_name}.sh"
                with open(script_file, 'w') as f:
                    f.write(script_content)
                os.chmod(script_file, 0o755)
                print(f"‚úÖ Generated connection script: {script_file}")
            
            if args.generate_env:
                env_content = generate_env_file(credentials, partition_name)
                env_file = f"{partition_name}.env"
                with open(env_file, 'w') as f:
                    f.write(env_content)
                print(f"‚úÖ Generated environment file: {env_file}")
        
        print_security_warning()
        
    else:
        # Process single partition
        config = load_config(args.config_file)
        partition_name = config.get('container', {}).get('name', 'partition')
        credentials = extract_credentials(config)
        
        if not credentials:
            print("‚ùå No credentials found in configuration file")
            sys.exit(1)
        
        print_credentials(credentials, partition_name)
        
        if args.generate_script:
            script_content = generate_connection_script(credentials, partition_name)
            script_file = f"connect_{partition_name}.sh"
            with open(script_file, 'w') as f:
                f.write(script_content)
            os.chmod(script_file, 0o755)
            print(f"‚úÖ Generated connection script: {script_file}")
        
        if args.generate_env:
            env_content = generate_env_file(credentials, partition_name)
            env_file = f"{partition_name}.env"
            with open(env_file, 'w') as f:
                f.write(env_content)
            print(f"‚úÖ Generated environment file: {env_file}")
        
        print_security_warning()


if __name__ == "__main__":
    main() 